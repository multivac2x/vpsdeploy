#!/bin/bash
# Phase 4: Registry Update

generate_caddyfile() {
    local registry_content="$1"
    local caddyfile

    caddyfile="# Auto-generated by setup-vps.sh — DO NOT EDIT MANUALLY\n"
    caddyfile+="# Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')\n\n"

    # Get sorted domain list for deterministic output
    local domains
    domains=$(echo "$registry_content" | jq -r '.domains | keys | sort[]')

    for domain in $domains; do
        local type
        type=$(echo "$registry_content" | jq -r --arg d "$domain" '.domains[$d].type')
        local port
        port=$(echo "$registry_content" | jq -r --arg d "$domain" '.domains[$d].port // empty')

        caddyfile+="# ── $domain ($type"
        [[ -n "$port" ]] && caddyfile+=", port $port"
        caddyfile+=") ──\n"

        # www redirect
        caddyfile+="www.$domain {\n"
        caddyfile+="    redir https://$domain{uri} permanent\n"
        caddyfile+="}\n\n"

        # Main domain block
        caddyfile+="$domain {\n"

        if [[ "$type" == "static" ]]; then
            caddyfile+="    root * /var/www/$domain\n"
            caddyfile+="    file_server\n\n"
            caddyfile+="    try_files {path} {path}.html /index.html\n\n"
            caddyfile+="    @static path *.css *.js *.png *.jpg *.jpeg *.gif *.svg *.woff *.woff2 *.ico\n"
            caddyfile+="    header @static Cache-Control \"public, max-age=31536000, immutable\"\n\n"
        else
            caddyfile+="    reverse_proxy localhost:$port\n\n"
        fi

        caddyfile+="    log {\n"
        caddyfile+="        output file /var/log/caddy/$domain.log\n"
        caddyfile+="        format json\n"
        caddyfile+="    }\n\n"

        caddyfile+="    header {\n"
        caddyfile+="        X-Content-Type-Options \"nosniff\"\n"
        caddyfile+="        X-Frame-Options \"DENY\"\n"
        caddyfile+="        Referrer-Policy \"strict-origin-when-cross-origin\"\n"
        caddyfile+="    }\n\n"

        caddyfile+="    encode gzip\n"
        caddyfile+="}\n\n"
    done

    echo "$caddyfile"
}

phase4_registry() {
    log_step "Phase 4: Registry Update"

    # DOMAIN is set globally from config.sh
    # shellcheck disable=SC2153
    local domain="$DOMAIN"

    local registry_path="/etc/caddy/domains.json"
    local temp_registry="/tmp/domains.json.$$"

    # Read existing registry or create empty
    if ssh_run "test -f $registry_path" &>/dev/null; then
        log_info "Reading existing registry..."
        ssh_run "cp $registry_path $temp_registry" 2>/dev/null || true
    else
        log_info "Creating new registry..."
        echo '{"version":1,"domains":{}}' > "$temp_registry"
    fi

    # Validate JSON if exists
    if [[ -f "$temp_registry" ]]; then
        if ! jq empty "$temp_registry" 2>/dev/null; then
            log_warn "Registry JSON is corrupted, backing up and creating fresh..."
            if [[ "$DRY_RUN" == false ]]; then
                ssh_run "sudo mv $registry_path ${registry_path}.corrupted.$(date +%Y%m%d_%H%M%S) 2>/dev/null || true"
            fi
            echo '{"version":1,"domains":{}}' > "$temp_registry"
        fi
    fi

    # Check for port conflicts if dynamic
    if [[ "$DOMAIN_TYPE" == "dynamic" ]]; then
        local conflicting_domain
        conflicting_domain=$(jq -r --arg port "$DOMAIN_PORT" --arg current_domain "$domain" '.domains | to_entries[] | select(.value.type == "dynamic" and .value.port == ($port|tonumber) and .key != $current_domain) | .key' "$temp_registry" 2>/dev/null || true)
        if [[ -n "$conflicting_domain" ]]; then
            log_error "Port conflict: Domain '$conflicting_domain' already uses port $DOMAIN_PORT"
            exit 1
        fi
    fi

    # Check for type changes
    local existing_type
    existing_type=$(jq -r --arg d "$domain" '.domains[$d].type // empty' "$temp_registry" 2>/dev/null || echo "")
    
    if [[ -n "$existing_type" ]] && [[ "$existing_type" != "$DOMAIN_TYPE" ]]; then
        log_info "Domain type changing from $existing_type to $DOMAIN_TYPE"
        
        # Handle dynamic -> static: stop and delete PM2 process
        if [[ "$existing_type" == "dynamic" ]] && [[ "$DOMAIN_TYPE" == "static" ]]; then
            log_info "Stopping and removing PM2 process for $domain..."
            if [[ "$DRY_RUN" == false ]]; then
                ssh_run "pm2 delete $domain 2>/dev/null || true"
                ssh_run "pm2 save" 2>/dev/null || true
                log_success "PM2 process stopped and deleted"
            fi
        fi
    fi

    # Merge/update domain entry
    log_info "Updating registry for domain: $domain"
    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Read current registry, update domain, write back
    local updated_json
    if [[ "$DOMAIN_TYPE" == "dynamic" ]]; then
        updated_json=$(jq --arg domain "$domain" --arg type "$DOMAIN_TYPE" --arg now "$now" --arg port "$DOMAIN_PORT" --arg apps_path "$VPS_APPS_PATH" '
            .domains[$domain] = (
                .domains[$domain] // {}
                | .type = $type
                | .updated_at = $now
                | .port = ($port | tonumber)
                | .app_dir = $apps_path + "/" + $domain
                | if .added_at | not then .added_at = $now else . end
            )
            | .updated_at = $now
        ' "$temp_registry" 2>/dev/null || echo '{"version":1,"domains":{}}')
    else
        updated_json=$(jq --arg domain "$domain" --arg type "$DOMAIN_TYPE" --arg now "$now" '
            .domains[$domain] = (
                .domains[$domain] // {}
                | .type = $type
                | .updated_at = $now
                | del(.port)
                | del(.app_dir)
                | if .added_at | not then .added_at = $now else . end
            )
            | .updated_at = $now
        ' "$temp_registry" 2>/dev/null || echo '{"version":1,"domains":{}}')
    fi

    if [[ "$DRY_RUN" == true ]]; then
        log_info "DRY RUN: Would update registry:"
        echo "$updated_json" | jq .
    else
        # Upload updated registry
        echo "$updated_json" | ssh_run "sudo tee $registry_path > /dev/null"
        ssh_run "sudo chmod 644 $registry_path"
        log_success "Registry updated"
    fi

    rm -f "$temp_registry"
}
